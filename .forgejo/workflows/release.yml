name: Release

permissions:
  contents: read

on:
  release:
    types:
      - published

env:
  CARGO_TERM_COLOR: always

jobs:
  verify_tag_matches_cargo:
    name: Verify release tag equals Cargo.toml version (and is highest)
    runs-on: ubuntu-latest
    env:
      TAG_VERSION: ${{ github.event.release.tag_name }}
    outputs:
      should_publish: ${{ steps.match_check.outputs.should_publish }}
    steps:
      - name: Checkout code at release tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}
          fetch-depth: 0

      - id: match_check
        name: Validate Cargo.toml version equals release tag and is highest
        run: |
          set -euo pipefail

          TAG="${TAG_VERSION}"
          if [ -z "${TAG:-}" ]; then
            echo "No tag name found in release event."
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if ! echo "$TAG" | grep -Eq '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Release tag '$TAG' does not match expected 'vX.Y.Z' format."
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          VERSION=${TAG#v}
          # Extract version from Cargo.toml (root crate)
          CURRENT=$(sed -n 's/^version = "\([^"]*\)"/\1/p' Cargo.toml | head -1 || true)

          if [ -z "${CURRENT:-}" ]; then
            echo "Could not determine current version from Cargo.toml."
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Release tag:     $TAG"
          echo "Cargo.toml:      $CURRENT"

          if [ "$CURRENT" != "$VERSION" ]; then
            echo "Release tag ($VERSION) does not match Cargo.toml version ($CURRENT)."
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Optional: ensure this tag is the highest semver among existing tags.
          git fetch --tags --force >/dev/null 2>&1 || true
          LAST_TAG=$(git tag -l 'v*' | sed 's/^v//' | sort -V | tail -n1 || true)
          if [ -n "$LAST_TAG" ]; then
            HIGHEST=$(printf "%s\n%s" "$LAST_TAG" "$VERSION" | sort -V | tail -n1)
            if [ "$HIGHEST" != "$VERSION" ]; then
              echo "Release tag ($VERSION) is not the highest known version (highest is $LAST_TAG)."
              echo "should_publish=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          echo "Tag matches Cargo.toml and is highest; proceeding."
          echo "should_publish=true" >> "$GITHUB_OUTPUT"

  publish_crate:
    name: Publish to crates.io
    runs-on: ubuntu-latest
    needs: verify_tag_matches_cargo
    if: needs.verify_tag_matches_cargo.outputs.should_publish == 'true'
    steps:
      - name: Checkout code at release tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}
          fetch-depth: 0

      - name: Setup Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          components: clippy,rustfmt

      - name: Preflight - fmt check
        run: cargo fmt --all --check

      - name: Preflight - clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Preflight - package manifest
        run: cargo package --list

      - name: Build release
        run: cargo build --release --verbose

      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
          PUBLISH_TO_CARGO: ${{ vars.PUBLISH_TO_CARGO }}
        run: |
          set -euo pipefail
          if [ -z "${CARGO_REGISTRY_TOKEN:-}" ]; then
            echo "CARGO_REGISTRY_TOKEN secret is not set. Configure it in repository secrets."
            exit 1
          fi
          DRY_FLAG="--dry-run"
          if [ "${PUBLISH_TO_CARGO:-}" = "true" ]; then
            DRY_FLAG=""
          fi
          cargo publish --token "$CARGO_REGISTRY_TOKEN" ${DRY_FLAG}
